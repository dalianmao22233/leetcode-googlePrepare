dfs:
class Solution {
    boolean[] visited;
    List<Integer>[] adj;
    public int countComponents(int n, int[][] edges) {
        adj = new List[n];
        visited = new boolean[n];
        for(int i = 0; i < n; ++i) adj[i] = new ArrayList();
        for(int[] edge : edges){
            adj[edge[0]].add(edge[1]);
            adj[edge[1]].add(edge[0]);
        }
        int union = 0;
        for(int i = 0; i < n; ++i){
            if(!visited[i]){
                dfs(i, -1);
                ++union;
            }
        }
        return union;     
    }
    public void dfs(int u, int parent){
        visited[u] = true;
        for(int nbr : adj[u]){
            if(nbr != parent && !visited[nbr]) dfs(nbr,u);
        }
    }
    
}

union find:
https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/discuss/77574/Easiest-2ms-Java-Solution
public int countComponents(int n, int[][] edges) {
    int[] roots = new int[n];
    for(int i = 0; i < n; i++) roots[i] = i; 

    for(int[] e : edges) {
        int root1 = find(roots, e[0]);
        int root2 = find(roots, e[1]);
        if(root1 != root2) {      
            roots[root1] = root2;  // union
            n--;
        }
    }
    return n;
}

public int find(int[] roots, int id) {
    while(roots[id] != id) {
        roots[id] = roots[roots[id]];  // optional: path compression
        id = roots[id];
    }
    return id;
}
//faster path compression in the comment:
public int find(int[] roots, int id) {
    int oid = id;
    while(roots[id] != id) id = roots[id];
    roots[oid] = id;  // path compression
    return id;
}
