1. iterative:time: O(n), 最差就是每个node都遍历一遍才找到LCA , space: O(1)
```
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        while(root != null) {
            if(root.val > p.val && root.val > q.val)
                root = root.left;
            else if ( root.val < p.val && root.val < q.val)
                root = root.right;
            else
                return root;
        }   
        return root;
}
```

2. recursive: 其实和LCA一样，就是基本条件处理不同，用BST的性质了。
time: O(n), 最差就是每个node都遍历一遍才找到LCA
space： O（n）height of a skewed BST could be N. 
```

public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null || root.val == p.val || root.val == q.val) {
        return root;
    }

    if (root.val < p.val && root.val < q.val) {
        return lowestCommonAncestor(root.right, p, q);
    } else if (root.val > p.val && root.val > q.val) {
        return lowestCommonAncestor(root.left, p, q);
    } else {
        return root; 
    }
}

```
