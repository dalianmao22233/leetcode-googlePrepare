https://leetcode.com/problems/accounts-merge/discuss/109158/Java-Solution-(Build-graph-%2B-DFS-search)

通过举例子可以得到算法的过程其实是把同一个人的email都用边联系起来， 然后无论用bfs/dfs,都是只拉出每个email 所连接的所有email，就能得到结果，bfs比dfs直观。
举例：
D, 0,4,3
D, 5,5,0
D, 1,4,0
D, 0,1,3
D, 4,1,3

算法第一部分就是将每一个数组里第一个email和其他的email联系起来，运行之后graph就是：
0=0,1,4,3,5
5=5,0
1=1,4,0
4=4,1,3,0
3=4,0

第二部分就是bfs/dfs了， visited set 作为记录，看是否重复计算了。

class Solution {
    public List<List<String>> accountsMerge(List<List<String>> accounts) {
        Map<String, Set<String>> graph = new HashMap<>();
        // 第一部分
        for (List<String> ls: accounts) {
            for (int i = 1; i < ls.size(); i++) {
                if (!graph.containsKey(ls.get(i))) {
                    graph.put(ls.get(i), new HashSet<String>());
                }
                //这两句少了谁也不行，如果少了这句，就会导致graph不全，当bfs/dfs时路径就会少走，导致ans不全，最后会变成：[[D, 0,1,4,3][D, 5]]
                //一定要建立所有的联系，不然每个graph set会不全。
                graph.get(ls.get(i)).add(ls.get(1)); 
                graph.get(ls.get(1)).add(ls.get(i));
            }
        }
        // 第二部分
        Set<String> visited = new HashSet<>();
        List<List<String>> res = new ArrayList<>();
        for (List<String> ls: accounts) {
            if (!visited.contains(ls.get(1))) {  // 这句容易忘，不然会有很多重复。
                List<String> ans = new ArrayList<>();
                bfs(graph, visited, ls.get(1), ans);   // bfs, dfs all works.
                Collections.sort(ans); // 注意排序！
                ans.add(0, ls.get(0));
                res.add(ans);
            }
        }
        return res;
    }
    public void dfs(Map<String,Set<String>> graph, Set<String> visited, String s,List<String> ans){
        ans.add(s);
        visited.add(s);
        for(String str:graph.get(s)){
            if(!visited.contains(str)){
                dfs(graph,visited,str,ans);
            }
        }
    }
    
    public void bfs(Map<String,Set<String>> graph, Set<String> visited, String s,List<String> ans){
        Queue<String> q=new LinkedList<>();
        q.add(s);
        visited.add(s);
        while(!q.isEmpty()){
            String t=q.poll();
            ans.add(t);
            for(String str:graph.get(t)){
                if(!visited.contains(str)){
                    q.add(str);
                    visited.add(str);
                } 
            }
        }
    }
}
