1. BFS, queue
class Solution {
    public List<String> findItinerary(List<List<String>> tickets) {
        Map<String, PriorityQueue<String>> map = new HashMap<>();
        List<String> res = new LinkedList<String>();
        Queue<String> queue = new LinkedList<>();
        
        for (List<String> t: tickets) {
            if (!map.containsKey(t.get(0))) {
                map.put(t.get(0), new PriorityQueue<String>());           
            }
            map.get(t.get(0)).offer(t.get(1));
        }
        queue.offer("JFK");
        
        while (!queue.isEmpty()) {
            String next = queue.peek();  // 注意这里先别poll, 因为要看map中的priorityqueue是否为空,如果是空，证明已经过河拆桥了，加到res中。
            if (map.containsKey(next) && map.get(next).size() > 0) {
                queue.offer(map.get(next).poll());
            } else {
                res.add(queue.poll());
            }
            System.out.println(map);
        }
        return res;
    }
    
}
input: [["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]
map:
{LHR=[SFO], MUC=[LHR], SFO=[SJC], JFK=[]}
{LHR=[SFO], MUC=[LHR], SFO=[SJC], JFK=[]}
{LHR=[SFO], MUC=[], SFO=[SJC], JFK=[]}
{LHR=[SFO], MUC=[], SFO=[SJC], JFK=[]}
{LHR=[], MUC=[], SFO=[SJC], JFK=[]}
{LHR=[], MUC=[], SFO=[SJC], JFK=[]}
{LHR=[], MUC=[], SFO=[], JFK=[]}
{LHR=[], MUC=[], SFO=[], JFK=[]}
{LHR=[], MUC=[], SFO=[], JFK=[]}



2.
Just Eulerian path. Greedy DFS, building the route backwards when retreating.


class Solution {
    public List<String> findItinerary(List<List<String>> tickets) {
        Map<String, PriorityQueue<String>> map = new HashMap<>();
        List<String> res = new LinkedList<String>();
        for (List<String> s : tickets) {
            map.computeIfAbsent(s.get(0), k -> new PriorityQueue<String>()).add(s.get(1));
            
        }

        
        Stack<String> st = new Stack<>();
        st.push("JFK");
        while(!st.isEmpty()){
            String src = st.peek();
            if(map.containsKey(src) && !map.get(src).isEmpty()){
                st.push(map.get(src).poll());
            }else{
                res.add(0,st.pop());
            }
        }
        return res;
    }
    
}
public List<String> findItinerary(String[][] tickets) {
    for (String[] ticket : tickets)
        targets.computeIfAbsent(ticket[0], k -> new PriorityQueue()).add(ticket[1]);
    visit("JFK");
    return route;
}

Map<String, PriorityQueue<String>> targets = new HashMap<>();
List<String> route = new LinkedList();

void visit(String airport) {
    while(targets.containsKey(airport) && !targets.get(airport).isEmpty())
        visit(targets.get(airport).poll());
    route.add(0, airport);
}
Iterative version:

public List<String> findItinerary(String[][] tickets) {
    Map<String, PriorityQueue<String>> targets = new HashMap<>();
    for (String[] ticket : tickets)
        targets.computeIfAbsent(ticket[0], k -> new PriorityQueue()).add(ticket[1]);
    List<String> route = new LinkedList();
    Stack<String> stack = new Stack<>();
    stack.push("JFK");
    while (!stack.empty()) {
        while (targets.containsKey(stack.peek()) && !targets.get(stack.peek()).isEmpty())
            stack.push(targets.get(stack.peek()).poll());
        route.add(0, stack.pop());
    }
    return route;
}
