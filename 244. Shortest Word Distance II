my solution: 类似于shortest word distance 1, 为了提高搜索效率，必须用hashmap.
class WordDistance {
    HashMap<String, List<Integer>> map;
    public WordDistance(String[] words) {
        map = new HashMap<String, List<Integer>>();
        for (int i = 0; i < words.length; i++) {
            if (map.containsKey(words[i])) {
                map.get(words[i]).add(i);
            } else {
                List<Integer> list = new ArrayList<>();
                list.add(i);
                map.put(words[i], list);
            }
        }
    }
    
    public int shortest(String word1, String word2) {
        int min = Integer.MAX_VALUE;
        List<Integer> list1 = map.get(word1);
        List<Integer> list2 = map.get(word2);
        if (map.containsKey(word1) && map.containsKey(word2)) {
            for (int i = 0; i < list1.size(); i++) {   // 这部分写的不太好，可以优化。下一个方法这里优化了。
                for (int j = 0; j < list2.size(); j++) {  
                    min = Math.min(Math.abs(list1.get(i)-list2.get(j)), min);
                }
            }
        }
        return min;
    }
}



更多优化：加cache:
Your solution is excellent but I think you can further optimize it by adding an in-memory cache 
which is going to store result for every (word1,word2) pair. 
Something like: Map<String, Integer> cache; 
where key can be "{word1}${word2}" and value is the result found. 
Since this API is going to get lot of calls, so on every call, 
consult cache to return result if it has been previously calculated. 
During cache check, it can check presence of 2 keys: "{word1}${word2}" and "{word2}${word1}" 
since word1 and word2 might be flipped.
For eg: 1st call .shortest("apple", "pear") and 2nd call .shortest("pear", "apple")

2. 优化一点点
public int shortest(String word1, String word2) {
    List<Integer> list1 = map.get(word1);
    List<Integer> list2 = map.get(word2);
    int ret = Integer.MAX_VALUE;
    for(int i = 0, j = 0; i < list1.size() && j < list2.size(); ) {   // 一个pass就能做完
        int index1 = list1.get(i), index2 = list2.get(j);
        if(index1 < index2) {
            ret = Math.min(ret, index2 - index1);
            i++;
        } else {
            ret = Math.min(ret, index1 - index2);
            j++;
        }
    }
    return ret;
}

/**
 * Your WordDistance object will be instantiated and called as such:
 * WordDistance obj = new WordDistance(words);
 * int param_1 = obj.shortest(word1,word2);
 */
