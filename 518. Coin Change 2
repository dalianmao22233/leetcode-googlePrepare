1.DP:有一个case: 
input: 0, [], 返回1. 这就是为什么dp[0]=1，并且我没设置边界check。
class Solution {
    public static int change(int amount, int[] coins) {
      int[] dp = new int[amount+1];
          dp[0] = 1;
          for (int j = 0; j < coins.length; j++) {
              for (int i = coins[j]; i <= amount; i++) { // dp[i-coins[j]] requires: start from i-coins[j] = 0.(dp[0])
                  dp[i] += dp[i-coins[j]];
              }
          }
          return dp[amount];
    }
}

2.
// LaiOffer

/*
coins[1, 2, 5]
i  dp[i]
0  1
1  1
2  2 (1, 1), (2)
3  2 (1, 2), (1, 1, 1)
4  3 (1, 1, 1, 1), (1, 1, 2), (2, 2)
5  4 


来Offer. dp[i][j]: number of combinations to amount j with the first i types of coins
        0   1  2  3  4  5
0(none) 1   0  0  0  0  0
1(1)    1   1  1  1  1  1
2(2)    1   1  2  2  3  3
3(5)    1   1  2  2  3  4

            No 2       one 2       two 2
dp[2][4] = dp[1][4] + dp[1][2] + dp[1][0] = 1 + 1 + 1
         = dp[1][4] + dp[2][2]
        

            No 5        one 5
dp[3][5] = dp[2][5] + dp[2][0] = 3 + 1 = 4
         = dp[2][5] + dp[3][0]
            
            No coins[i - 1]      one coins[i - 1]                     two coins[i - 1]
dp[i][j] =  dp[i - 1][j] + dp[i - 1][j -coins[i - 1]] + dp[i - 1][j - coins[i - 1] * 2] + ...
         =  dp[i - 1][j] + dp[i][j - coins[i - 1]]

*/


class Solution {
    // method1: Solution2 of LaiOffer
    // O(nm) time, O(nm) space
    public int change(int amount, int[] coins) {
        if(coins == null || coins.length == 0) return (amount == 0 ? 1 : 0);
        int n = coins.length;
        int[][] dp = new int[n + 1][amount + 1];
        
        for(int j = 0; j <= amount; j++) {
            if(j == 0) {
                dp[0][j] = 1;
            }else {
                dp[0][j] = 0;
            }
        }
        
        for(int i = 1; i <= n; i++) {
            for(int j = 0; j <= amount; j++) {
                dp[i][j] = dp[i - 1][j];
                if(j >= coins[i - 1]) dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i - 1]]; // method1: O(nm)
            }
        }
        
        return dp[n][amount];
    }
    
    
    // method2: O(nm) time, O(m) space
    // 1D array to save space
    public int change2(int amount, int[] coins) {
        if(coins == null || coins.length == 0) return (amount == 0 ? 1 : 0);
        int n = coins.length;
        int[] dp = new int[amount + 1];
        
        for(int j = 0; j <= amount; j++) {
            if(j == 0) {
                dp[j] = 1;
            }else {
                dp[j] = 0;
            }
        }
        
        for(int i = 1; i <= n; i++) {
            for(int j = 0; j <= amount; j++) {
                if(j >= coins[i - 1]) dp[j] += dp[j - coins[i - 1]]; 
            }
        }
        
        return dp[amount];
    }
}







// 1D array is good enough

/*
<<Knapsack problem - Java solution with thinking process O(nm) Time and O(m) Space>>

    public int change(int amount, int[] coins) {
        int[][] dp = new int[coins.length+1][amount+1];
        dp[0][0] = 1;
        
        for (int i = 1; i <= coins.length; i++) {
            dp[i][0] = 1;
            for (int j = 1; j <= amount; j++) {
                dp[i][j] = dp[i-1][j] + (j >= coins[i-1] ? dp[i][j-coins[i-1]] : 0);
            }
        }
        return dp[coins.length][amount];
    }

Now we can see that dp[i][j] only rely on dp[i-1][j] and dp[i][j-coins[i]], then we can optimize the space by only using one-dimension array.

    public int change(int amount, int[] coins) {
        int[] dp = new int[amount + 1];
        dp[0] = 1;
        for (int coin : coins) {
            for (int i = coin; i <= amount; i++) {
                dp[i] += dp[i-coin];
            }
        }
        return dp[amount];
    }


*/



explaination:   https://www.youtube.com/watch?time_continue=579&v=jaNZ83Q3QGc has good explanation!!!
If outer loop is amount, you are considering every coin at every stage.
Let's start with amount 2: it can be made from 2 and 1 + 1, so 2 combinations. 
For amount 3 you would consider every coin again, which would mean that you're trying dp[amount - 1] and dp[amount - 2], 
which is: 2 (as there are 2 combinations for amount 2) and 1 (1 combination for amount 1).
So in this case you have 3 combinations for amount 3:
1 + 2 - taken from dp[amount - 2]
2 + 1, 1 + 1 + 1 - taken from dp[amount - 1]
You can see is one duplicate: 1 + 2 and 2 + 1
If outer loop is coins, you are NOT considering every coing at every stage
Let's assume you've already calculated all dps for coin with value 1. So for every amount there is just one combination, 
dp array looks like that: [1, 1, 1, 1, 1...]
Now we are doing all calculations with value 2. We are at amount 2, so again, amount 2 has 2 combinations: 1 + 1 and 2. 
Makes sense, no duplicates.
For amount 3 you are NOT considering every coin again - you are just considering ending every combination with 2, 
so ONLY dp[amount - 2].
That would make only two combinations for amount 3:
1 + 1 + 1 - taken as previous value of dp[3], calculated for coin value 1
1 + 2 - taken from dp[amount - 2]
Hopefully it shows why we don't have duplicates - all combinations are started with lowest coins, 
there is no way to have lowest coin at the end. You can think that you have all SORTED combinations.
