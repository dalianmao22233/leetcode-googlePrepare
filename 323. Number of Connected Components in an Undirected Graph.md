首选union find: 保证union/find操作近乎O(1)

```
class Solution {
    
    public int countComponents(int n, int[][] edges) {
        int[] p = new int[n];
        
        for (int i = 0; i < n; i++) {
            p[i] = i;
        }
        
        for (int[] e: edges) {
            int root1 = find(e[0], p);
            int root2 = find(e[1], p);
            if (root1 != root2) {
                //一条边上2个点不在同一个集合，要合并
                p[root1] = root2;
                n--; // 之前是每个点组成一个集合，合并之后就少了一个
            }
        }
        return n;
        
    }
    public int find (int x, int[] p) {  //路径压缩， 如果有按秩合并，就是O(1)，否则就是O(logn)，但是平均复杂度还是O(1)
        if (p[x] != x) {
            p[x] = find(p[x], p);
        }
        return p[x];
    }    
}
```

dfs:

```
class Solution {
    boolean[] visited;
    List<Integer>[] adj;
    public int countComponents(int n, int[][] edges) {
        adj = new List[n];
        visited = new boolean[n];
        for(int i = 0; i < n; ++i) adj[i] = new ArrayList();
        for(int[] edge : edges){
            adj[edge[0]].add(edge[1]);
            adj[edge[1]].add(edge[0]);
        }
        int union = 0;
        for(int i = 0; i < n; ++i){
            if(!visited[i]){
                dfs(i, -1);
                ++union;
            }
        }
        return union;     
    }
    public void dfs(int u, int parent){
        visited[u] = true;
        for(int nbr : adj[u]){
            if(nbr != parent && !visited[nbr]) dfs(nbr,u);
        }
    }
    
}
```

