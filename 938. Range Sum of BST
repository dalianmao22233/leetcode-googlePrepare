找low node - high node path之间的所有node, 并且满足node.val 在low~high之间：
因为这是BST，所以可以直接看左子树右子树，不用traverse搜索。
1. recursive:
class Solution {
    int res;
    public int rangeSumBST(TreeNode root, int low, int high) {
        res = 0;
        dfs(root, low, high);
        return res;
    }
    public void dfs(TreeNode node, int l, int r) {
        if (node != null) {
            if (l <= node.val && node.val <= r) {
                res += node.val;
            }
            if (l < node.val) {
                dfs(node.left, l , r);
            }
            if (node.val < r) {
                dfs(node.right, l, r);
            }
        }
    }
}

2. iterative:
class Solution {
    public int rangeSumBST(TreeNode root, int L, int R) {
        int ans = 0;
        Stack<TreeNode> stack = new Stack();
        stack.push(root);
        while (!stack.isEmpty()) {
            TreeNode node = stack.pop();
            if (node != null) {
                if (L <= node.val && node.val <= R)
                    ans += node.val;
                if (L < node.val)
                    stack.push(node.left);
                if (node.val < R)
                    stack.push(node.right);
            }
        }
        return ans;
    }
}
