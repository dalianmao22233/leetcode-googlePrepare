1. union find
// path compression + rank : N + Mlg * N, 平均是O(1), time: O(n^2)
class Solution {
    class UF {
        int[] parent;
        int[] rank;
        int count;
        // 这道题和number of island不同，不需要每个点都check,因为是对称的。M是n*n的。。
        // 所以用1维的数组就可以表示关系了
        public UF(int n) {
            parent = new int[n];
            rank = new int[n];
            for (int i = 0; i < n; i++) {
                parent[i] = i;
                count++;
            }
        }
        public int find(int i) {  // path compression
            // if (parent[i] != i) {
            //     parent[i] = find(parent[i]);
            // }   这种是我的做法，总之两个差不多。
            while (parent[i] != i) {
                parent[i] = parent[parent[i]];
                i = parent[i];
            }
            return parent[i];
        }
        public void union(int i, int j) {    // rank
            int ri = find(i);
            int rj = find(j);
            if (ri != rj) {
                if (rank[ri] > rank[rj]) {
                    parent[rj] = ri;
                } else if (rank[ri] < rank[rj]) {
                    parent[ri] = rj;
                } else {
                    parent[ri] = rj;
                    rank[rj]++;    
                }
                count--;
            }
        }
        public int getCount() {
            return count;
        }
    }
    public int findCircleNum(int[][] M) {
        if (M == null || M.length == 0) {
            return 0;
        }
        int m = M.length;
        UF uf = new UF(m);
        
        for (int i = 0; i < m; i++) {
            for (int j = i+1; j < m; j++) {
                if (M[i][j] == 1) {
                    // 如果i和j是朋友，合并i和j
                    // 和number islands不同，这里不用M[i][j] = 0； 因为那道题是需要把所有1都标记为0，为了不被重复union
                    // 那道题是设置了M[i][j] = 0之后要根据情况分别union上下左右4个点，可能会check到之前走过的’1‘点。
                    // 这里不需要check是因为不会有重复的风险，每次遇到=1的情况就merge 2个人，不需要看上下左右，没那么复杂
                    // 岛那道题不是2个人关系的概念，是点坐标，所以不能简单的merge. 
                    uf.union(i, j);
                }
            }
        }
        return uf.getCount();
    }
    
}


2. dfs:
Time: O(n^2), traverse all element.
public class Solution {
    public int findCircleNum(int[][] M) {
        boolean[] visited = new boolean[M.length]; //visited[i] means if ith person is visited in this algorithm， 
        //boolean占位更少。
        int count = 0;
        for(int i = 0; i < M.length; i++) {
            if(!visited[i]) {
                dfs(M, visited, i);
                count++;
            }
        }
        return count;
    }
    private void dfs(int[][] M, boolean[] visited, int person) {
        for(int other = 0; other < M.length; other++) {
            if(M[person][other] == 1 && !visited[other]) {
                //We found an unvisited person in the current friend cycle 
                visited[other] = true;
                dfs(M, visited, other); //Start DFS on this new found person
            }
        }
    }
}

不用visited数组：
public int findCircleNum(int[][] M) {
    int count = 0;
    
    for(int i = 0; i < M.length; i++) 
        if(M[i][i] != 0) {
            dfs(M, i);
            count++;
        }
        
    return count;
}

void dfs(int[][] M, int u) {
    M[u][u] = 0;  //其实这个和number island很像，直接把这个点标记为0沉下去。
    for(int v = 0; v < M[u].length; v++) 
        if(M[v][v] != 0 && M[u][v] == 1)
            dfs(M, v);
}


3. bfs:Time: O(n^2), traverse all element.
public class Solution {
    public int findCircleNum(int[][] M) {
        int[] visited = new int[M.length];
        int count = 0;
        Queue < Integer > queue = new LinkedList < > ();
        for (int i = 0; i < M.length; i++) {
            if (visited[i] == 0) {
                queue.add(i);
                while (!queue.isEmpty()) {
                    int s = queue.remove();
                    visited[s] = 1;
                    for (int j = 0; j < M.length; j++) {
                        if (M[s][j] == 1 && visited[j] == 0)
                            queue.add(j);
                    }
                }
                count++;
            }
        }
        return count;
    }
}
